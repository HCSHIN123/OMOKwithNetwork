// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: test.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_test_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_test_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "enum.pb.h"
#include "struct.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_test_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_test_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_test_2eproto;
namespace Protocol {
class C_CREATEROOM;
struct C_CREATEROOMDefaultTypeInternal;
extern C_CREATEROOMDefaultTypeInternal _C_CREATEROOM_default_instance_;
class C_ENDGAME;
struct C_ENDGAMEDefaultTypeInternal;
extern C_ENDGAMEDefaultTypeInternal _C_ENDGAME_default_instance_;
class C_ENTER;
struct C_ENTERDefaultTypeInternal;
extern C_ENTERDefaultTypeInternal _C_ENTER_default_instance_;
class C_ENTERLOBBY;
struct C_ENTERLOBBYDefaultTypeInternal;
extern C_ENTERLOBBYDefaultTypeInternal _C_ENTERLOBBY_default_instance_;
class C_EXITROOM;
struct C_EXITROOMDefaultTypeInternal;
extern C_EXITROOMDefaultTypeInternal _C_EXITROOM_default_instance_;
class C_MYTURN;
struct C_MYTURNDefaultTypeInternal;
extern C_MYTURNDefaultTypeInternal _C_MYTURN_default_instance_;
class C_READY;
struct C_READYDefaultTypeInternal;
extern C_READYDefaultTypeInternal _C_READY_default_instance_;
class C_REGAME;
struct C_REGAMEDefaultTypeInternal;
extern C_REGAMEDefaultTypeInternal _C_REGAME_default_instance_;
class S_CONNECT;
struct S_CONNECTDefaultTypeInternal;
extern S_CONNECTDefaultTypeInternal _S_CONNECT_default_instance_;
class S_CREATEROOM;
struct S_CREATEROOMDefaultTypeInternal;
extern S_CREATEROOMDefaultTypeInternal _S_CREATEROOM_default_instance_;
class S_DISCONNECT;
struct S_DISCONNECTDefaultTypeInternal;
extern S_DISCONNECTDefaultTypeInternal _S_DISCONNECT_default_instance_;
class S_ENDGAME;
struct S_ENDGAMEDefaultTypeInternal;
extern S_ENDGAMEDefaultTypeInternal _S_ENDGAME_default_instance_;
class S_ENEMYENTER;
struct S_ENEMYENTERDefaultTypeInternal;
extern S_ENEMYENTERDefaultTypeInternal _S_ENEMYENTER_default_instance_;
class S_ENEMYREADY;
struct S_ENEMYREADYDefaultTypeInternal;
extern S_ENEMYREADYDefaultTypeInternal _S_ENEMYREADY_default_instance_;
class S_ENEMYTURN;
struct S_ENEMYTURNDefaultTypeInternal;
extern S_ENEMYTURNDefaultTypeInternal _S_ENEMYTURN_default_instance_;
class S_ENTER;
struct S_ENTERDefaultTypeInternal;
extern S_ENTERDefaultTypeInternal _S_ENTER_default_instance_;
class S_ENTERLOBBY;
struct S_ENTERLOBBYDefaultTypeInternal;
extern S_ENTERLOBBYDefaultTypeInternal _S_ENTERLOBBY_default_instance_;
class S_GAMEOVER;
struct S_GAMEOVERDefaultTypeInternal;
extern S_GAMEOVERDefaultTypeInternal _S_GAMEOVER_default_instance_;
class S_STARTGAME;
struct S_STARTGAMEDefaultTypeInternal;
extern S_STARTGAMEDefaultTypeInternal _S_STARTGAME_default_instance_;
class S_TURNBACK;
struct S_TURNBACKDefaultTypeInternal;
extern S_TURNBACKDefaultTypeInternal _S_TURNBACK_default_instance_;
}  // namespace Protocol
PROTOBUF_NAMESPACE_OPEN
template<> ::Protocol::C_CREATEROOM* Arena::CreateMaybeMessage<::Protocol::C_CREATEROOM>(Arena*);
template<> ::Protocol::C_ENDGAME* Arena::CreateMaybeMessage<::Protocol::C_ENDGAME>(Arena*);
template<> ::Protocol::C_ENTER* Arena::CreateMaybeMessage<::Protocol::C_ENTER>(Arena*);
template<> ::Protocol::C_ENTERLOBBY* Arena::CreateMaybeMessage<::Protocol::C_ENTERLOBBY>(Arena*);
template<> ::Protocol::C_EXITROOM* Arena::CreateMaybeMessage<::Protocol::C_EXITROOM>(Arena*);
template<> ::Protocol::C_MYTURN* Arena::CreateMaybeMessage<::Protocol::C_MYTURN>(Arena*);
template<> ::Protocol::C_READY* Arena::CreateMaybeMessage<::Protocol::C_READY>(Arena*);
template<> ::Protocol::C_REGAME* Arena::CreateMaybeMessage<::Protocol::C_REGAME>(Arena*);
template<> ::Protocol::S_CONNECT* Arena::CreateMaybeMessage<::Protocol::S_CONNECT>(Arena*);
template<> ::Protocol::S_CREATEROOM* Arena::CreateMaybeMessage<::Protocol::S_CREATEROOM>(Arena*);
template<> ::Protocol::S_DISCONNECT* Arena::CreateMaybeMessage<::Protocol::S_DISCONNECT>(Arena*);
template<> ::Protocol::S_ENDGAME* Arena::CreateMaybeMessage<::Protocol::S_ENDGAME>(Arena*);
template<> ::Protocol::S_ENEMYENTER* Arena::CreateMaybeMessage<::Protocol::S_ENEMYENTER>(Arena*);
template<> ::Protocol::S_ENEMYREADY* Arena::CreateMaybeMessage<::Protocol::S_ENEMYREADY>(Arena*);
template<> ::Protocol::S_ENEMYTURN* Arena::CreateMaybeMessage<::Protocol::S_ENEMYTURN>(Arena*);
template<> ::Protocol::S_ENTER* Arena::CreateMaybeMessage<::Protocol::S_ENTER>(Arena*);
template<> ::Protocol::S_ENTERLOBBY* Arena::CreateMaybeMessage<::Protocol::S_ENTERLOBBY>(Arena*);
template<> ::Protocol::S_GAMEOVER* Arena::CreateMaybeMessage<::Protocol::S_GAMEOVER>(Arena*);
template<> ::Protocol::S_STARTGAME* Arena::CreateMaybeMessage<::Protocol::S_STARTGAME>(Arena*);
template<> ::Protocol::S_TURNBACK* Arena::CreateMaybeMessage<::Protocol::S_TURNBACK>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Protocol {

// ===================================================================

class C_REGAME final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.C_REGAME) */ {
 public:
  inline C_REGAME() : C_REGAME(nullptr) {}
  explicit PROTOBUF_CONSTEXPR C_REGAME(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_REGAME(const C_REGAME& from);
  C_REGAME(C_REGAME&& from) noexcept
    : C_REGAME() {
    *this = ::std::move(from);
  }

  inline C_REGAME& operator=(const C_REGAME& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_REGAME& operator=(C_REGAME&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_REGAME& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_REGAME* internal_default_instance() {
    return reinterpret_cast<const C_REGAME*>(
               &_C_REGAME_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(C_REGAME& a, C_REGAME& b) {
    a.Swap(&b);
  }
  inline void Swap(C_REGAME* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_REGAME* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_REGAME* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_REGAME>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const C_REGAME& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const C_REGAME& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_REGAME";
  }
  protected:
  explicit C_REGAME(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.C_REGAME)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class C_EXITROOM final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.C_EXITROOM) */ {
 public:
  inline C_EXITROOM() : C_EXITROOM(nullptr) {}
  explicit PROTOBUF_CONSTEXPR C_EXITROOM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_EXITROOM(const C_EXITROOM& from);
  C_EXITROOM(C_EXITROOM&& from) noexcept
    : C_EXITROOM() {
    *this = ::std::move(from);
  }

  inline C_EXITROOM& operator=(const C_EXITROOM& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_EXITROOM& operator=(C_EXITROOM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_EXITROOM& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_EXITROOM* internal_default_instance() {
    return reinterpret_cast<const C_EXITROOM*>(
               &_C_EXITROOM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(C_EXITROOM& a, C_EXITROOM& b) {
    a.Swap(&b);
  }
  inline void Swap(C_EXITROOM* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_EXITROOM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_EXITROOM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_EXITROOM>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const C_EXITROOM& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const C_EXITROOM& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_EXITROOM";
  }
  protected:
  explicit C_EXITROOM(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.C_EXITROOM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class C_READY final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_READY) */ {
 public:
  inline C_READY() : C_READY(nullptr) {}
  ~C_READY() override;
  explicit PROTOBUF_CONSTEXPR C_READY(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_READY(const C_READY& from);
  C_READY(C_READY&& from) noexcept
    : C_READY() {
    *this = ::std::move(from);
  }

  inline C_READY& operator=(const C_READY& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_READY& operator=(C_READY&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_READY& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_READY* internal_default_instance() {
    return reinterpret_cast<const C_READY*>(
               &_C_READY_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(C_READY& a, C_READY& b) {
    a.Swap(&b);
  }
  inline void Swap(C_READY* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_READY* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_READY* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_READY>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_READY& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_READY& from) {
    C_READY::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_READY* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_READY";
  }
  protected:
  explicit C_READY(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReadyFieldNumber = 1,
  };
  // bool ready = 1;
  void clear_ready();
  bool ready() const;
  void set_ready(bool value);
  private:
  bool _internal_ready() const;
  void _internal_set_ready(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_READY)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ready_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class C_ENDGAME final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_ENDGAME) */ {
 public:
  inline C_ENDGAME() : C_ENDGAME(nullptr) {}
  ~C_ENDGAME() override;
  explicit PROTOBUF_CONSTEXPR C_ENDGAME(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_ENDGAME(const C_ENDGAME& from);
  C_ENDGAME(C_ENDGAME&& from) noexcept
    : C_ENDGAME() {
    *this = ::std::move(from);
  }

  inline C_ENDGAME& operator=(const C_ENDGAME& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_ENDGAME& operator=(C_ENDGAME&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_ENDGAME& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_ENDGAME* internal_default_instance() {
    return reinterpret_cast<const C_ENDGAME*>(
               &_C_ENDGAME_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(C_ENDGAME& a, C_ENDGAME& b) {
    a.Swap(&b);
  }
  inline void Swap(C_ENDGAME* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_ENDGAME* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_ENDGAME* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_ENDGAME>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_ENDGAME& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_ENDGAME& from) {
    C_ENDGAME::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_ENDGAME* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_ENDGAME";
  }
  protected:
  explicit C_ENDGAME(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomidFieldNumber = 1,
  };
  // int32 roomid = 1;
  void clear_roomid();
  int32_t roomid() const;
  void set_roomid(int32_t value);
  private:
  int32_t _internal_roomid() const;
  void _internal_set_roomid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_ENDGAME)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t roomid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class C_ENTER final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_ENTER) */ {
 public:
  inline C_ENTER() : C_ENTER(nullptr) {}
  ~C_ENTER() override;
  explicit PROTOBUF_CONSTEXPR C_ENTER(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_ENTER(const C_ENTER& from);
  C_ENTER(C_ENTER&& from) noexcept
    : C_ENTER() {
    *this = ::std::move(from);
  }

  inline C_ENTER& operator=(const C_ENTER& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_ENTER& operator=(C_ENTER&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_ENTER& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_ENTER* internal_default_instance() {
    return reinterpret_cast<const C_ENTER*>(
               &_C_ENTER_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(C_ENTER& a, C_ENTER& b) {
    a.Swap(&b);
  }
  inline void Swap(C_ENTER* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_ENTER* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_ENTER* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_ENTER>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_ENTER& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_ENTER& from) {
    C_ENTER::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_ENTER* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_ENTER";
  }
  protected:
  explicit C_ENTER(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomidFieldNumber = 1,
  };
  // int32 roomid = 1;
  void clear_roomid();
  int32_t roomid() const;
  void set_roomid(int32_t value);
  private:
  int32_t _internal_roomid() const;
  void _internal_set_roomid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_ENTER)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t roomid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class C_MYTURN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_MYTURN) */ {
 public:
  inline C_MYTURN() : C_MYTURN(nullptr) {}
  ~C_MYTURN() override;
  explicit PROTOBUF_CONSTEXPR C_MYTURN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_MYTURN(const C_MYTURN& from);
  C_MYTURN(C_MYTURN&& from) noexcept
    : C_MYTURN() {
    *this = ::std::move(from);
  }

  inline C_MYTURN& operator=(const C_MYTURN& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_MYTURN& operator=(C_MYTURN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_MYTURN& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_MYTURN* internal_default_instance() {
    return reinterpret_cast<const C_MYTURN*>(
               &_C_MYTURN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(C_MYTURN& a, C_MYTURN& b) {
    a.Swap(&b);
  }
  inline void Swap(C_MYTURN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_MYTURN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_MYTURN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_MYTURN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_MYTURN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_MYTURN& from) {
    C_MYTURN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_MYTURN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_MYTURN";
  }
  protected:
  explicit C_MYTURN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // int32 x = 1;
  void clear_x();
  int32_t x() const;
  void set_x(int32_t value);
  private:
  int32_t _internal_x() const;
  void _internal_set_x(int32_t value);
  public:

  // int32 y = 2;
  void clear_y();
  int32_t y() const;
  void set_y(int32_t value);
  private:
  int32_t _internal_y() const;
  void _internal_set_y(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_MYTURN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t x_;
    int32_t y_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class C_CREATEROOM final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.C_CREATEROOM) */ {
 public:
  inline C_CREATEROOM() : C_CREATEROOM(nullptr) {}
  explicit PROTOBUF_CONSTEXPR C_CREATEROOM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_CREATEROOM(const C_CREATEROOM& from);
  C_CREATEROOM(C_CREATEROOM&& from) noexcept
    : C_CREATEROOM() {
    *this = ::std::move(from);
  }

  inline C_CREATEROOM& operator=(const C_CREATEROOM& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_CREATEROOM& operator=(C_CREATEROOM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_CREATEROOM& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_CREATEROOM* internal_default_instance() {
    return reinterpret_cast<const C_CREATEROOM*>(
               &_C_CREATEROOM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(C_CREATEROOM& a, C_CREATEROOM& b) {
    a.Swap(&b);
  }
  inline void Swap(C_CREATEROOM* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_CREATEROOM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_CREATEROOM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_CREATEROOM>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const C_CREATEROOM& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const C_CREATEROOM& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_CREATEROOM";
  }
  protected:
  explicit C_CREATEROOM(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.C_CREATEROOM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class C_ENTERLOBBY final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.C_ENTERLOBBY) */ {
 public:
  inline C_ENTERLOBBY() : C_ENTERLOBBY(nullptr) {}
  explicit PROTOBUF_CONSTEXPR C_ENTERLOBBY(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_ENTERLOBBY(const C_ENTERLOBBY& from);
  C_ENTERLOBBY(C_ENTERLOBBY&& from) noexcept
    : C_ENTERLOBBY() {
    *this = ::std::move(from);
  }

  inline C_ENTERLOBBY& operator=(const C_ENTERLOBBY& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_ENTERLOBBY& operator=(C_ENTERLOBBY&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_ENTERLOBBY& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_ENTERLOBBY* internal_default_instance() {
    return reinterpret_cast<const C_ENTERLOBBY*>(
               &_C_ENTERLOBBY_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(C_ENTERLOBBY& a, C_ENTERLOBBY& b) {
    a.Swap(&b);
  }
  inline void Swap(C_ENTERLOBBY* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_ENTERLOBBY* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_ENTERLOBBY* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_ENTERLOBBY>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const C_ENTERLOBBY& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const C_ENTERLOBBY& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_ENTERLOBBY";
  }
  protected:
  explicit C_ENTERLOBBY(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.C_ENTERLOBBY)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class S_ENDGAME final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_ENDGAME) */ {
 public:
  inline S_ENDGAME() : S_ENDGAME(nullptr) {}
  ~S_ENDGAME() override;
  explicit PROTOBUF_CONSTEXPR S_ENDGAME(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_ENDGAME(const S_ENDGAME& from);
  S_ENDGAME(S_ENDGAME&& from) noexcept
    : S_ENDGAME() {
    *this = ::std::move(from);
  }

  inline S_ENDGAME& operator=(const S_ENDGAME& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_ENDGAME& operator=(S_ENDGAME&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_ENDGAME& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_ENDGAME* internal_default_instance() {
    return reinterpret_cast<const S_ENDGAME*>(
               &_S_ENDGAME_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(S_ENDGAME& a, S_ENDGAME& b) {
    a.Swap(&b);
  }
  inline void Swap(S_ENDGAME* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_ENDGAME* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_ENDGAME* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_ENDGAME>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_ENDGAME& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_ENDGAME& from) {
    S_ENDGAME::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_ENDGAME* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_ENDGAME";
  }
  protected:
  explicit S_ENDGAME(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomidFieldNumber = 1,
  };
  // int32 roomid = 1;
  void clear_roomid();
  int32_t roomid() const;
  void set_roomid(int32_t value);
  private:
  int32_t _internal_roomid() const;
  void _internal_set_roomid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_ENDGAME)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t roomid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class S_CREATEROOM final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_CREATEROOM) */ {
 public:
  inline S_CREATEROOM() : S_CREATEROOM(nullptr) {}
  ~S_CREATEROOM() override;
  explicit PROTOBUF_CONSTEXPR S_CREATEROOM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_CREATEROOM(const S_CREATEROOM& from);
  S_CREATEROOM(S_CREATEROOM&& from) noexcept
    : S_CREATEROOM() {
    *this = ::std::move(from);
  }

  inline S_CREATEROOM& operator=(const S_CREATEROOM& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_CREATEROOM& operator=(S_CREATEROOM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_CREATEROOM& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_CREATEROOM* internal_default_instance() {
    return reinterpret_cast<const S_CREATEROOM*>(
               &_S_CREATEROOM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(S_CREATEROOM& a, S_CREATEROOM& b) {
    a.Swap(&b);
  }
  inline void Swap(S_CREATEROOM* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_CREATEROOM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_CREATEROOM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_CREATEROOM>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_CREATEROOM& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_CREATEROOM& from) {
    S_CREATEROOM::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_CREATEROOM* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_CREATEROOM";
  }
  protected:
  explicit S_CREATEROOM(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomFieldNumber = 1,
  };
  // .Protocol.Room room = 1;
  bool has_room() const;
  private:
  bool _internal_has_room() const;
  public:
  void clear_room();
  const ::Protocol::Room& room() const;
  PROTOBUF_NODISCARD ::Protocol::Room* release_room();
  ::Protocol::Room* mutable_room();
  void set_allocated_room(::Protocol::Room* room);
  private:
  const ::Protocol::Room& _internal_room() const;
  ::Protocol::Room* _internal_mutable_room();
  public:
  void unsafe_arena_set_allocated_room(
      ::Protocol::Room* room);
  ::Protocol::Room* unsafe_arena_release_room();

  // @@protoc_insertion_point(class_scope:Protocol.S_CREATEROOM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::Room* room_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class S_ENTERLOBBY final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_ENTERLOBBY) */ {
 public:
  inline S_ENTERLOBBY() : S_ENTERLOBBY(nullptr) {}
  ~S_ENTERLOBBY() override;
  explicit PROTOBUF_CONSTEXPR S_ENTERLOBBY(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_ENTERLOBBY(const S_ENTERLOBBY& from);
  S_ENTERLOBBY(S_ENTERLOBBY&& from) noexcept
    : S_ENTERLOBBY() {
    *this = ::std::move(from);
  }

  inline S_ENTERLOBBY& operator=(const S_ENTERLOBBY& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_ENTERLOBBY& operator=(S_ENTERLOBBY&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_ENTERLOBBY& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_ENTERLOBBY* internal_default_instance() {
    return reinterpret_cast<const S_ENTERLOBBY*>(
               &_S_ENTERLOBBY_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(S_ENTERLOBBY& a, S_ENTERLOBBY& b) {
    a.Swap(&b);
  }
  inline void Swap(S_ENTERLOBBY* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_ENTERLOBBY* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_ENTERLOBBY* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_ENTERLOBBY>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_ENTERLOBBY& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_ENTERLOBBY& from) {
    S_ENTERLOBBY::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_ENTERLOBBY* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_ENTERLOBBY";
  }
  protected:
  explicit S_ENTERLOBBY(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomsFieldNumber = 1,
  };
  // repeated .Protocol.Room rooms = 1;
  int rooms_size() const;
  private:
  int _internal_rooms_size() const;
  public:
  void clear_rooms();
  ::Protocol::Room* mutable_rooms(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::Room >*
      mutable_rooms();
  private:
  const ::Protocol::Room& _internal_rooms(int index) const;
  ::Protocol::Room* _internal_add_rooms();
  public:
  const ::Protocol::Room& rooms(int index) const;
  ::Protocol::Room* add_rooms();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::Room >&
      rooms() const;

  // @@protoc_insertion_point(class_scope:Protocol.S_ENTERLOBBY)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::Room > rooms_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class S_DISCONNECT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_DISCONNECT) */ {
 public:
  inline S_DISCONNECT() : S_DISCONNECT(nullptr) {}
  ~S_DISCONNECT() override;
  explicit PROTOBUF_CONSTEXPR S_DISCONNECT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_DISCONNECT(const S_DISCONNECT& from);
  S_DISCONNECT(S_DISCONNECT&& from) noexcept
    : S_DISCONNECT() {
    *this = ::std::move(from);
  }

  inline S_DISCONNECT& operator=(const S_DISCONNECT& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_DISCONNECT& operator=(S_DISCONNECT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_DISCONNECT& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_DISCONNECT* internal_default_instance() {
    return reinterpret_cast<const S_DISCONNECT*>(
               &_S_DISCONNECT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(S_DISCONNECT& a, S_DISCONNECT& b) {
    a.Swap(&b);
  }
  inline void Swap(S_DISCONNECT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_DISCONNECT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_DISCONNECT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_DISCONNECT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_DISCONNECT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_DISCONNECT& from) {
    S_DISCONNECT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_DISCONNECT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_DISCONNECT";
  }
  protected:
  explicit S_DISCONNECT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // int32 id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_DISCONNECT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class S_CONNECT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_CONNECT) */ {
 public:
  inline S_CONNECT() : S_CONNECT(nullptr) {}
  ~S_CONNECT() override;
  explicit PROTOBUF_CONSTEXPR S_CONNECT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_CONNECT(const S_CONNECT& from);
  S_CONNECT(S_CONNECT&& from) noexcept
    : S_CONNECT() {
    *this = ::std::move(from);
  }

  inline S_CONNECT& operator=(const S_CONNECT& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_CONNECT& operator=(S_CONNECT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_CONNECT& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_CONNECT* internal_default_instance() {
    return reinterpret_cast<const S_CONNECT*>(
               &_S_CONNECT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(S_CONNECT& a, S_CONNECT& b) {
    a.Swap(&b);
  }
  inline void Swap(S_CONNECT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_CONNECT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_CONNECT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_CONNECT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_CONNECT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_CONNECT& from) {
    S_CONNECT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_CONNECT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_CONNECT";
  }
  protected:
  explicit S_CONNECT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // repeated .Protocol.Player players = 2;
  int players_size() const;
  private:
  int _internal_players_size() const;
  public:
  void clear_players();
  ::Protocol::Player* mutable_players(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::Player >*
      mutable_players();
  private:
  const ::Protocol::Player& _internal_players(int index) const;
  ::Protocol::Player* _internal_add_players();
  public:
  const ::Protocol::Player& players(int index) const;
  ::Protocol::Player* add_players();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::Player >&
      players() const;

  // int32 id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_CONNECT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::Player > players_;
    int32_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class S_ENTER final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_ENTER) */ {
 public:
  inline S_ENTER() : S_ENTER(nullptr) {}
  ~S_ENTER() override;
  explicit PROTOBUF_CONSTEXPR S_ENTER(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_ENTER(const S_ENTER& from);
  S_ENTER(S_ENTER&& from) noexcept
    : S_ENTER() {
    *this = ::std::move(from);
  }

  inline S_ENTER& operator=(const S_ENTER& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_ENTER& operator=(S_ENTER&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_ENTER& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_ENTER* internal_default_instance() {
    return reinterpret_cast<const S_ENTER*>(
               &_S_ENTER_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(S_ENTER& a, S_ENTER& b) {
    a.Swap(&b);
  }
  inline void Swap(S_ENTER* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_ENTER* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_ENTER* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_ENTER>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_ENTER& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_ENTER& from) {
    S_ENTER::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_ENTER* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_ENTER";
  }
  protected:
  explicit S_ENTER(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoominfoFieldNumber = 2,
    kCangameFieldNumber = 1,
  };
  // .Protocol.Room roominfo = 2;
  bool has_roominfo() const;
  private:
  bool _internal_has_roominfo() const;
  public:
  void clear_roominfo();
  const ::Protocol::Room& roominfo() const;
  PROTOBUF_NODISCARD ::Protocol::Room* release_roominfo();
  ::Protocol::Room* mutable_roominfo();
  void set_allocated_roominfo(::Protocol::Room* roominfo);
  private:
  const ::Protocol::Room& _internal_roominfo() const;
  ::Protocol::Room* _internal_mutable_roominfo();
  public:
  void unsafe_arena_set_allocated_roominfo(
      ::Protocol::Room* roominfo);
  ::Protocol::Room* unsafe_arena_release_roominfo();

  // bool cangame = 1;
  void clear_cangame();
  bool cangame() const;
  void set_cangame(bool value);
  private:
  bool _internal_cangame() const;
  void _internal_set_cangame(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_ENTER)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::Room* roominfo_;
    bool cangame_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class S_STARTGAME final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_STARTGAME) */ {
 public:
  inline S_STARTGAME() : S_STARTGAME(nullptr) {}
  ~S_STARTGAME() override;
  explicit PROTOBUF_CONSTEXPR S_STARTGAME(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_STARTGAME(const S_STARTGAME& from);
  S_STARTGAME(S_STARTGAME&& from) noexcept
    : S_STARTGAME() {
    *this = ::std::move(from);
  }

  inline S_STARTGAME& operator=(const S_STARTGAME& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_STARTGAME& operator=(S_STARTGAME&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_STARTGAME& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_STARTGAME* internal_default_instance() {
    return reinterpret_cast<const S_STARTGAME*>(
               &_S_STARTGAME_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(S_STARTGAME& a, S_STARTGAME& b) {
    a.Swap(&b);
  }
  inline void Swap(S_STARTGAME* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_STARTGAME* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_STARTGAME* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_STARTGAME>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_STARTGAME& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_STARTGAME& from) {
    S_STARTGAME::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_STARTGAME* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_STARTGAME";
  }
  protected:
  explicit S_STARTGAME(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColorFieldNumber = 1,
  };
  // .Protocol.STONE_COLOR color = 1;
  void clear_color();
  ::Protocol::STONE_COLOR color() const;
  void set_color(::Protocol::STONE_COLOR value);
  private:
  ::Protocol::STONE_COLOR _internal_color() const;
  void _internal_set_color(::Protocol::STONE_COLOR value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_STARTGAME)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int color_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class S_ENEMYTURN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_ENEMYTURN) */ {
 public:
  inline S_ENEMYTURN() : S_ENEMYTURN(nullptr) {}
  ~S_ENEMYTURN() override;
  explicit PROTOBUF_CONSTEXPR S_ENEMYTURN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_ENEMYTURN(const S_ENEMYTURN& from);
  S_ENEMYTURN(S_ENEMYTURN&& from) noexcept
    : S_ENEMYTURN() {
    *this = ::std::move(from);
  }

  inline S_ENEMYTURN& operator=(const S_ENEMYTURN& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_ENEMYTURN& operator=(S_ENEMYTURN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_ENEMYTURN& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_ENEMYTURN* internal_default_instance() {
    return reinterpret_cast<const S_ENEMYTURN*>(
               &_S_ENEMYTURN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(S_ENEMYTURN& a, S_ENEMYTURN& b) {
    a.Swap(&b);
  }
  inline void Swap(S_ENEMYTURN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_ENEMYTURN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_ENEMYTURN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_ENEMYTURN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_ENEMYTURN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_ENEMYTURN& from) {
    S_ENEMYTURN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_ENEMYTURN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_ENEMYTURN";
  }
  protected:
  explicit S_ENEMYTURN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // int32 x = 1;
  void clear_x();
  int32_t x() const;
  void set_x(int32_t value);
  private:
  int32_t _internal_x() const;
  void _internal_set_x(int32_t value);
  public:

  // int32 y = 2;
  void clear_y();
  int32_t y() const;
  void set_y(int32_t value);
  private:
  int32_t _internal_y() const;
  void _internal_set_y(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_ENEMYTURN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t x_;
    int32_t y_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class S_GAMEOVER final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_GAMEOVER) */ {
 public:
  inline S_GAMEOVER() : S_GAMEOVER(nullptr) {}
  ~S_GAMEOVER() override;
  explicit PROTOBUF_CONSTEXPR S_GAMEOVER(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_GAMEOVER(const S_GAMEOVER& from);
  S_GAMEOVER(S_GAMEOVER&& from) noexcept
    : S_GAMEOVER() {
    *this = ::std::move(from);
  }

  inline S_GAMEOVER& operator=(const S_GAMEOVER& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_GAMEOVER& operator=(S_GAMEOVER&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_GAMEOVER& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_GAMEOVER* internal_default_instance() {
    return reinterpret_cast<const S_GAMEOVER*>(
               &_S_GAMEOVER_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(S_GAMEOVER& a, S_GAMEOVER& b) {
    a.Swap(&b);
  }
  inline void Swap(S_GAMEOVER* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_GAMEOVER* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_GAMEOVER* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_GAMEOVER>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_GAMEOVER& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_GAMEOVER& from) {
    S_GAMEOVER::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_GAMEOVER* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_GAMEOVER";
  }
  protected:
  explicit S_GAMEOVER(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kResultFieldNumber = 3,
  };
  // int32 x = 1;
  void clear_x();
  int32_t x() const;
  void set_x(int32_t value);
  private:
  int32_t _internal_x() const;
  void _internal_set_x(int32_t value);
  public:

  // int32 y = 2;
  void clear_y();
  int32_t y() const;
  void set_y(int32_t value);
  private:
  int32_t _internal_y() const;
  void _internal_set_y(int32_t value);
  public:

  // .Protocol.GAME_OVER result = 3;
  void clear_result();
  ::Protocol::GAME_OVER result() const;
  void set_result(::Protocol::GAME_OVER value);
  private:
  ::Protocol::GAME_OVER _internal_result() const;
  void _internal_set_result(::Protocol::GAME_OVER value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_GAMEOVER)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t x_;
    int32_t y_;
    int result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class S_TURNBACK final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_TURNBACK) */ {
 public:
  inline S_TURNBACK() : S_TURNBACK(nullptr) {}
  ~S_TURNBACK() override;
  explicit PROTOBUF_CONSTEXPR S_TURNBACK(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_TURNBACK(const S_TURNBACK& from);
  S_TURNBACK(S_TURNBACK&& from) noexcept
    : S_TURNBACK() {
    *this = ::std::move(from);
  }

  inline S_TURNBACK& operator=(const S_TURNBACK& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_TURNBACK& operator=(S_TURNBACK&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_TURNBACK& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_TURNBACK* internal_default_instance() {
    return reinterpret_cast<const S_TURNBACK*>(
               &_S_TURNBACK_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(S_TURNBACK& a, S_TURNBACK& b) {
    a.Swap(&b);
  }
  inline void Swap(S_TURNBACK* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_TURNBACK* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_TURNBACK* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_TURNBACK>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_TURNBACK& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_TURNBACK& from) {
    S_TURNBACK::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_TURNBACK* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_TURNBACK";
  }
  protected:
  explicit S_TURNBACK(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // int32 x = 1;
  void clear_x();
  int32_t x() const;
  void set_x(int32_t value);
  private:
  int32_t _internal_x() const;
  void _internal_set_x(int32_t value);
  public:

  // int32 y = 2;
  void clear_y();
  int32_t y() const;
  void set_y(int32_t value);
  private:
  int32_t _internal_y() const;
  void _internal_set_y(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_TURNBACK)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t x_;
    int32_t y_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class S_ENEMYENTER final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_ENEMYENTER) */ {
 public:
  inline S_ENEMYENTER() : S_ENEMYENTER(nullptr) {}
  ~S_ENEMYENTER() override;
  explicit PROTOBUF_CONSTEXPR S_ENEMYENTER(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_ENEMYENTER(const S_ENEMYENTER& from);
  S_ENEMYENTER(S_ENEMYENTER&& from) noexcept
    : S_ENEMYENTER() {
    *this = ::std::move(from);
  }

  inline S_ENEMYENTER& operator=(const S_ENEMYENTER& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_ENEMYENTER& operator=(S_ENEMYENTER&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_ENEMYENTER& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_ENEMYENTER* internal_default_instance() {
    return reinterpret_cast<const S_ENEMYENTER*>(
               &_S_ENEMYENTER_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(S_ENEMYENTER& a, S_ENEMYENTER& b) {
    a.Swap(&b);
  }
  inline void Swap(S_ENEMYENTER* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_ENEMYENTER* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_ENEMYENTER* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_ENEMYENTER>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_ENEMYENTER& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_ENEMYENTER& from) {
    S_ENEMYENTER::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_ENEMYENTER* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_ENEMYENTER";
  }
  protected:
  explicit S_ENEMYENTER(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnterFieldNumber = 1,
  };
  // bool enter = 1;
  void clear_enter();
  bool enter() const;
  void set_enter(bool value);
  private:
  bool _internal_enter() const;
  void _internal_set_enter(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_ENEMYENTER)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool enter_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_test_2eproto;
};
// -------------------------------------------------------------------

class S_ENEMYREADY final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.S_ENEMYREADY) */ {
 public:
  inline S_ENEMYREADY() : S_ENEMYREADY(nullptr) {}
  explicit PROTOBUF_CONSTEXPR S_ENEMYREADY(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_ENEMYREADY(const S_ENEMYREADY& from);
  S_ENEMYREADY(S_ENEMYREADY&& from) noexcept
    : S_ENEMYREADY() {
    *this = ::std::move(from);
  }

  inline S_ENEMYREADY& operator=(const S_ENEMYREADY& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_ENEMYREADY& operator=(S_ENEMYREADY&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_ENEMYREADY& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_ENEMYREADY* internal_default_instance() {
    return reinterpret_cast<const S_ENEMYREADY*>(
               &_S_ENEMYREADY_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(S_ENEMYREADY& a, S_ENEMYREADY& b) {
    a.Swap(&b);
  }
  inline void Swap(S_ENEMYREADY* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_ENEMYREADY* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_ENEMYREADY* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_ENEMYREADY>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const S_ENEMYREADY& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const S_ENEMYREADY& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_ENEMYREADY";
  }
  protected:
  explicit S_ENEMYREADY(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.S_ENEMYREADY)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_test_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// C_REGAME

// -------------------------------------------------------------------

// C_EXITROOM

// -------------------------------------------------------------------

// C_READY

// bool ready = 1;
inline void C_READY::clear_ready() {
  _impl_.ready_ = false;
}
inline bool C_READY::_internal_ready() const {
  return _impl_.ready_;
}
inline bool C_READY::ready() const {
  // @@protoc_insertion_point(field_get:Protocol.C_READY.ready)
  return _internal_ready();
}
inline void C_READY::_internal_set_ready(bool value) {
  
  _impl_.ready_ = value;
}
inline void C_READY::set_ready(bool value) {
  _internal_set_ready(value);
  // @@protoc_insertion_point(field_set:Protocol.C_READY.ready)
}

// -------------------------------------------------------------------

// C_ENDGAME

// int32 roomid = 1;
inline void C_ENDGAME::clear_roomid() {
  _impl_.roomid_ = 0;
}
inline int32_t C_ENDGAME::_internal_roomid() const {
  return _impl_.roomid_;
}
inline int32_t C_ENDGAME::roomid() const {
  // @@protoc_insertion_point(field_get:Protocol.C_ENDGAME.roomid)
  return _internal_roomid();
}
inline void C_ENDGAME::_internal_set_roomid(int32_t value) {
  
  _impl_.roomid_ = value;
}
inline void C_ENDGAME::set_roomid(int32_t value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:Protocol.C_ENDGAME.roomid)
}

// -------------------------------------------------------------------

// C_ENTER

// int32 roomid = 1;
inline void C_ENTER::clear_roomid() {
  _impl_.roomid_ = 0;
}
inline int32_t C_ENTER::_internal_roomid() const {
  return _impl_.roomid_;
}
inline int32_t C_ENTER::roomid() const {
  // @@protoc_insertion_point(field_get:Protocol.C_ENTER.roomid)
  return _internal_roomid();
}
inline void C_ENTER::_internal_set_roomid(int32_t value) {
  
  _impl_.roomid_ = value;
}
inline void C_ENTER::set_roomid(int32_t value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:Protocol.C_ENTER.roomid)
}

// -------------------------------------------------------------------

// C_MYTURN

// int32 x = 1;
inline void C_MYTURN::clear_x() {
  _impl_.x_ = 0;
}
inline int32_t C_MYTURN::_internal_x() const {
  return _impl_.x_;
}
inline int32_t C_MYTURN::x() const {
  // @@protoc_insertion_point(field_get:Protocol.C_MYTURN.x)
  return _internal_x();
}
inline void C_MYTURN::_internal_set_x(int32_t value) {
  
  _impl_.x_ = value;
}
inline void C_MYTURN::set_x(int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Protocol.C_MYTURN.x)
}

// int32 y = 2;
inline void C_MYTURN::clear_y() {
  _impl_.y_ = 0;
}
inline int32_t C_MYTURN::_internal_y() const {
  return _impl_.y_;
}
inline int32_t C_MYTURN::y() const {
  // @@protoc_insertion_point(field_get:Protocol.C_MYTURN.y)
  return _internal_y();
}
inline void C_MYTURN::_internal_set_y(int32_t value) {
  
  _impl_.y_ = value;
}
inline void C_MYTURN::set_y(int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Protocol.C_MYTURN.y)
}

// -------------------------------------------------------------------

// C_CREATEROOM

// -------------------------------------------------------------------

// C_ENTERLOBBY

// -------------------------------------------------------------------

// S_ENDGAME

// int32 roomid = 1;
inline void S_ENDGAME::clear_roomid() {
  _impl_.roomid_ = 0;
}
inline int32_t S_ENDGAME::_internal_roomid() const {
  return _impl_.roomid_;
}
inline int32_t S_ENDGAME::roomid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ENDGAME.roomid)
  return _internal_roomid();
}
inline void S_ENDGAME::_internal_set_roomid(int32_t value) {
  
  _impl_.roomid_ = value;
}
inline void S_ENDGAME::set_roomid(int32_t value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_ENDGAME.roomid)
}

// -------------------------------------------------------------------

// S_CREATEROOM

// .Protocol.Room room = 1;
inline bool S_CREATEROOM::_internal_has_room() const {
  return this != internal_default_instance() && _impl_.room_ != nullptr;
}
inline bool S_CREATEROOM::has_room() const {
  return _internal_has_room();
}
inline const ::Protocol::Room& S_CREATEROOM::_internal_room() const {
  const ::Protocol::Room* p = _impl_.room_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::Room&>(
      ::Protocol::_Room_default_instance_);
}
inline const ::Protocol::Room& S_CREATEROOM::room() const {
  // @@protoc_insertion_point(field_get:Protocol.S_CREATEROOM.room)
  return _internal_room();
}
inline void S_CREATEROOM::unsafe_arena_set_allocated_room(
    ::Protocol::Room* room) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.room_);
  }
  _impl_.room_ = room;
  if (room) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_CREATEROOM.room)
}
inline ::Protocol::Room* S_CREATEROOM::release_room() {
  
  ::Protocol::Room* temp = _impl_.room_;
  _impl_.room_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::Room* S_CREATEROOM::unsafe_arena_release_room() {
  // @@protoc_insertion_point(field_release:Protocol.S_CREATEROOM.room)
  
  ::Protocol::Room* temp = _impl_.room_;
  _impl_.room_ = nullptr;
  return temp;
}
inline ::Protocol::Room* S_CREATEROOM::_internal_mutable_room() {
  
  if (_impl_.room_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::Room>(GetArenaForAllocation());
    _impl_.room_ = p;
  }
  return _impl_.room_;
}
inline ::Protocol::Room* S_CREATEROOM::mutable_room() {
  ::Protocol::Room* _msg = _internal_mutable_room();
  // @@protoc_insertion_point(field_mutable:Protocol.S_CREATEROOM.room)
  return _msg;
}
inline void S_CREATEROOM::set_allocated_room(::Protocol::Room* room) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.room_);
  }
  if (room) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(room));
    if (message_arena != submessage_arena) {
      room = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, room, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.room_ = room;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_CREATEROOM.room)
}

// -------------------------------------------------------------------

// S_ENTERLOBBY

// repeated .Protocol.Room rooms = 1;
inline int S_ENTERLOBBY::_internal_rooms_size() const {
  return _impl_.rooms_.size();
}
inline int S_ENTERLOBBY::rooms_size() const {
  return _internal_rooms_size();
}
inline ::Protocol::Room* S_ENTERLOBBY::mutable_rooms(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_ENTERLOBBY.rooms)
  return _impl_.rooms_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::Room >*
S_ENTERLOBBY::mutable_rooms() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_ENTERLOBBY.rooms)
  return &_impl_.rooms_;
}
inline const ::Protocol::Room& S_ENTERLOBBY::_internal_rooms(int index) const {
  return _impl_.rooms_.Get(index);
}
inline const ::Protocol::Room& S_ENTERLOBBY::rooms(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_ENTERLOBBY.rooms)
  return _internal_rooms(index);
}
inline ::Protocol::Room* S_ENTERLOBBY::_internal_add_rooms() {
  return _impl_.rooms_.Add();
}
inline ::Protocol::Room* S_ENTERLOBBY::add_rooms() {
  ::Protocol::Room* _add = _internal_add_rooms();
  // @@protoc_insertion_point(field_add:Protocol.S_ENTERLOBBY.rooms)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::Room >&
S_ENTERLOBBY::rooms() const {
  // @@protoc_insertion_point(field_list:Protocol.S_ENTERLOBBY.rooms)
  return _impl_.rooms_;
}

// -------------------------------------------------------------------

// S_DISCONNECT

// int32 id = 1;
inline void S_DISCONNECT::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t S_DISCONNECT::_internal_id() const {
  return _impl_.id_;
}
inline int32_t S_DISCONNECT::id() const {
  // @@protoc_insertion_point(field_get:Protocol.S_DISCONNECT.id)
  return _internal_id();
}
inline void S_DISCONNECT::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void S_DISCONNECT::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Protocol.S_DISCONNECT.id)
}

// -------------------------------------------------------------------

// S_CONNECT

// int32 id = 1;
inline void S_CONNECT::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t S_CONNECT::_internal_id() const {
  return _impl_.id_;
}
inline int32_t S_CONNECT::id() const {
  // @@protoc_insertion_point(field_get:Protocol.S_CONNECT.id)
  return _internal_id();
}
inline void S_CONNECT::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void S_CONNECT::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Protocol.S_CONNECT.id)
}

// repeated .Protocol.Player players = 2;
inline int S_CONNECT::_internal_players_size() const {
  return _impl_.players_.size();
}
inline int S_CONNECT::players_size() const {
  return _internal_players_size();
}
inline ::Protocol::Player* S_CONNECT::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_CONNECT.players)
  return _impl_.players_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::Player >*
S_CONNECT::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_CONNECT.players)
  return &_impl_.players_;
}
inline const ::Protocol::Player& S_CONNECT::_internal_players(int index) const {
  return _impl_.players_.Get(index);
}
inline const ::Protocol::Player& S_CONNECT::players(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_CONNECT.players)
  return _internal_players(index);
}
inline ::Protocol::Player* S_CONNECT::_internal_add_players() {
  return _impl_.players_.Add();
}
inline ::Protocol::Player* S_CONNECT::add_players() {
  ::Protocol::Player* _add = _internal_add_players();
  // @@protoc_insertion_point(field_add:Protocol.S_CONNECT.players)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::Player >&
S_CONNECT::players() const {
  // @@protoc_insertion_point(field_list:Protocol.S_CONNECT.players)
  return _impl_.players_;
}

// -------------------------------------------------------------------

// S_ENTER

// bool cangame = 1;
inline void S_ENTER::clear_cangame() {
  _impl_.cangame_ = false;
}
inline bool S_ENTER::_internal_cangame() const {
  return _impl_.cangame_;
}
inline bool S_ENTER::cangame() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ENTER.cangame)
  return _internal_cangame();
}
inline void S_ENTER::_internal_set_cangame(bool value) {
  
  _impl_.cangame_ = value;
}
inline void S_ENTER::set_cangame(bool value) {
  _internal_set_cangame(value);
  // @@protoc_insertion_point(field_set:Protocol.S_ENTER.cangame)
}

// .Protocol.Room roominfo = 2;
inline bool S_ENTER::_internal_has_roominfo() const {
  return this != internal_default_instance() && _impl_.roominfo_ != nullptr;
}
inline bool S_ENTER::has_roominfo() const {
  return _internal_has_roominfo();
}
inline const ::Protocol::Room& S_ENTER::_internal_roominfo() const {
  const ::Protocol::Room* p = _impl_.roominfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::Room&>(
      ::Protocol::_Room_default_instance_);
}
inline const ::Protocol::Room& S_ENTER::roominfo() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ENTER.roominfo)
  return _internal_roominfo();
}
inline void S_ENTER::unsafe_arena_set_allocated_roominfo(
    ::Protocol::Room* roominfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.roominfo_);
  }
  _impl_.roominfo_ = roominfo;
  if (roominfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_ENTER.roominfo)
}
inline ::Protocol::Room* S_ENTER::release_roominfo() {
  
  ::Protocol::Room* temp = _impl_.roominfo_;
  _impl_.roominfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::Room* S_ENTER::unsafe_arena_release_roominfo() {
  // @@protoc_insertion_point(field_release:Protocol.S_ENTER.roominfo)
  
  ::Protocol::Room* temp = _impl_.roominfo_;
  _impl_.roominfo_ = nullptr;
  return temp;
}
inline ::Protocol::Room* S_ENTER::_internal_mutable_roominfo() {
  
  if (_impl_.roominfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::Room>(GetArenaForAllocation());
    _impl_.roominfo_ = p;
  }
  return _impl_.roominfo_;
}
inline ::Protocol::Room* S_ENTER::mutable_roominfo() {
  ::Protocol::Room* _msg = _internal_mutable_roominfo();
  // @@protoc_insertion_point(field_mutable:Protocol.S_ENTER.roominfo)
  return _msg;
}
inline void S_ENTER::set_allocated_roominfo(::Protocol::Room* roominfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.roominfo_);
  }
  if (roominfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(roominfo));
    if (message_arena != submessage_arena) {
      roominfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, roominfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.roominfo_ = roominfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_ENTER.roominfo)
}

// -------------------------------------------------------------------

// S_STARTGAME

// .Protocol.STONE_COLOR color = 1;
inline void S_STARTGAME::clear_color() {
  _impl_.color_ = 0;
}
inline ::Protocol::STONE_COLOR S_STARTGAME::_internal_color() const {
  return static_cast< ::Protocol::STONE_COLOR >(_impl_.color_);
}
inline ::Protocol::STONE_COLOR S_STARTGAME::color() const {
  // @@protoc_insertion_point(field_get:Protocol.S_STARTGAME.color)
  return _internal_color();
}
inline void S_STARTGAME::_internal_set_color(::Protocol::STONE_COLOR value) {
  
  _impl_.color_ = value;
}
inline void S_STARTGAME::set_color(::Protocol::STONE_COLOR value) {
  _internal_set_color(value);
  // @@protoc_insertion_point(field_set:Protocol.S_STARTGAME.color)
}

// -------------------------------------------------------------------

// S_ENEMYTURN

// int32 x = 1;
inline void S_ENEMYTURN::clear_x() {
  _impl_.x_ = 0;
}
inline int32_t S_ENEMYTURN::_internal_x() const {
  return _impl_.x_;
}
inline int32_t S_ENEMYTURN::x() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ENEMYTURN.x)
  return _internal_x();
}
inline void S_ENEMYTURN::_internal_set_x(int32_t value) {
  
  _impl_.x_ = value;
}
inline void S_ENEMYTURN::set_x(int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Protocol.S_ENEMYTURN.x)
}

// int32 y = 2;
inline void S_ENEMYTURN::clear_y() {
  _impl_.y_ = 0;
}
inline int32_t S_ENEMYTURN::_internal_y() const {
  return _impl_.y_;
}
inline int32_t S_ENEMYTURN::y() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ENEMYTURN.y)
  return _internal_y();
}
inline void S_ENEMYTURN::_internal_set_y(int32_t value) {
  
  _impl_.y_ = value;
}
inline void S_ENEMYTURN::set_y(int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Protocol.S_ENEMYTURN.y)
}

// -------------------------------------------------------------------

// S_GAMEOVER

// int32 x = 1;
inline void S_GAMEOVER::clear_x() {
  _impl_.x_ = 0;
}
inline int32_t S_GAMEOVER::_internal_x() const {
  return _impl_.x_;
}
inline int32_t S_GAMEOVER::x() const {
  // @@protoc_insertion_point(field_get:Protocol.S_GAMEOVER.x)
  return _internal_x();
}
inline void S_GAMEOVER::_internal_set_x(int32_t value) {
  
  _impl_.x_ = value;
}
inline void S_GAMEOVER::set_x(int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Protocol.S_GAMEOVER.x)
}

// int32 y = 2;
inline void S_GAMEOVER::clear_y() {
  _impl_.y_ = 0;
}
inline int32_t S_GAMEOVER::_internal_y() const {
  return _impl_.y_;
}
inline int32_t S_GAMEOVER::y() const {
  // @@protoc_insertion_point(field_get:Protocol.S_GAMEOVER.y)
  return _internal_y();
}
inline void S_GAMEOVER::_internal_set_y(int32_t value) {
  
  _impl_.y_ = value;
}
inline void S_GAMEOVER::set_y(int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Protocol.S_GAMEOVER.y)
}

// .Protocol.GAME_OVER result = 3;
inline void S_GAMEOVER::clear_result() {
  _impl_.result_ = 0;
}
inline ::Protocol::GAME_OVER S_GAMEOVER::_internal_result() const {
  return static_cast< ::Protocol::GAME_OVER >(_impl_.result_);
}
inline ::Protocol::GAME_OVER S_GAMEOVER::result() const {
  // @@protoc_insertion_point(field_get:Protocol.S_GAMEOVER.result)
  return _internal_result();
}
inline void S_GAMEOVER::_internal_set_result(::Protocol::GAME_OVER value) {
  
  _impl_.result_ = value;
}
inline void S_GAMEOVER::set_result(::Protocol::GAME_OVER value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:Protocol.S_GAMEOVER.result)
}

// -------------------------------------------------------------------

// S_TURNBACK

// int32 x = 1;
inline void S_TURNBACK::clear_x() {
  _impl_.x_ = 0;
}
inline int32_t S_TURNBACK::_internal_x() const {
  return _impl_.x_;
}
inline int32_t S_TURNBACK::x() const {
  // @@protoc_insertion_point(field_get:Protocol.S_TURNBACK.x)
  return _internal_x();
}
inline void S_TURNBACK::_internal_set_x(int32_t value) {
  
  _impl_.x_ = value;
}
inline void S_TURNBACK::set_x(int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Protocol.S_TURNBACK.x)
}

// int32 y = 2;
inline void S_TURNBACK::clear_y() {
  _impl_.y_ = 0;
}
inline int32_t S_TURNBACK::_internal_y() const {
  return _impl_.y_;
}
inline int32_t S_TURNBACK::y() const {
  // @@protoc_insertion_point(field_get:Protocol.S_TURNBACK.y)
  return _internal_y();
}
inline void S_TURNBACK::_internal_set_y(int32_t value) {
  
  _impl_.y_ = value;
}
inline void S_TURNBACK::set_y(int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Protocol.S_TURNBACK.y)
}

// -------------------------------------------------------------------

// S_ENEMYENTER

// bool enter = 1;
inline void S_ENEMYENTER::clear_enter() {
  _impl_.enter_ = false;
}
inline bool S_ENEMYENTER::_internal_enter() const {
  return _impl_.enter_;
}
inline bool S_ENEMYENTER::enter() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ENEMYENTER.enter)
  return _internal_enter();
}
inline void S_ENEMYENTER::_internal_set_enter(bool value) {
  
  _impl_.enter_ = value;
}
inline void S_ENEMYENTER::set_enter(bool value) {
  _internal_set_enter(value);
  // @@protoc_insertion_point(field_set:Protocol.S_ENEMYENTER.enter)
}

// -------------------------------------------------------------------

// S_ENEMYREADY

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Protocol

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_test_2eproto
